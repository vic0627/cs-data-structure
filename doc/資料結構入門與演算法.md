# 資料結構入門與演算法

> *資料結構是資料的表示法，也就是指電腦中儲存資料的方法。*

## 資料結構的定義

輔助程式設計最佳化的方法論，他不僅討論到儲存的資料，同時也考慮到彼此之間的關係與運算，使達到加快執行速度與減少記憶體佔用空間等功用。

### 資料與資訊

- 資料（Data）：一種未經處理的原始文字（Word）、數字（Number）、符號（Symbol）或圖形（Graph）等，沒有評估價值的基本元素或項目。
- 資訊（Information）：經過處理過程，以特定方式有系統地整理、歸納甚至分析的資料。
- 資料處理（Data Processing）：對資料進行有系統的整理如紀錄、排序、合併、整合、計算、統計等，使原始資料符合需求，成為有用的資訊。

### 資料的特性

依據資料在計算機程式語言中的存在層次來區分，可分為以下三種型態：

- 基本資料型態（Primitive Data Type）：不能以其他型態來定義的資料型態，或稱為*純量資料型態（Scalar Data Type）*，例如整數（int）、浮點數（float）、字元（char）等。
- 結構化資料型態（Structured Data Type）：比基本資料型態更高一層的資料型態，或稱為*虛擬資料型態（Virtual Data Type）*，例如字串（string）、陣列（array）、指標（pointer）、串列（list）、檔案（file）等。
- 抽象資料型態（Abstract Data Type, ADT）：主要關注於資料的邏輯結構以及對這些結構進行的操作，而不考慮具體的實作方式，定義了資料型態所具備的資料與抽象關係，在電腦中表示一種「資訊隱藏」（Information Hiding）的精神。

## 演算法

一個程式能否快速、有效地完成預定任務，取決於是否選對了資料結構，而程式能否清楚、正確地解決問題，取決於演算法。

> *可執行的程式 = 資料結構 + 演算法*

### 演算法的條件

| 演算法特性 | 內容與說明 |
| --- | --- |
| 輸入（Input） | 0 或多個輸入資料，且必須有清楚的描述或定義。 |
| 輸出（Output） | 至少會有一個輸出結果，不可以沒有。 |
| 明確性（Definiteness） | 每個指令或步驟必須是簡潔明確且不含糊。 |
| 有限性（Finiteness） | 在有限步驟後一定會結束，不會產生無窮迴路。 |
| 有效性（Effectiveness） | 步驟清楚可行，能用紙筆計算求解。 |

### 演算法的表現方式

- 虛擬語言（Pseudo-Language）：接近高階程式語言，但不能直接放進電腦中執行。
- 表格或圖形：陣列、樹狀圖、矩陣等。
- 流程圖（Flow Diagram）：通用的表示法，必須使用某些圖形符號。
- 程式語言：直接以可讀性高的高階語言來表示。

### 常見的演算法

- 分治法（Divide and conquer）：將一個難以直接解決的大問題，依照相同概念分割成兩個或多個子問題，使子問題規模不段縮小，直到子問題足夠簡單，最後將所有子問題解合併，得到原問題的答案。常見應用有快速排序法（quick sort）、遞迴演算法（recursion）、大整數除法。
- 遞迴法：
  - 與分治法概念相像，都是將問題分割使規模越來越小，而在某些程式語言中，函數不單只能夠被其他函數呼叫，也能夠引用自身，這種功能就被稱作「遞迴」。
  - 遞迴至少要定一兩種條件，一是*可以反覆執行的遞迴過程*，二是*一個跳出執行過程的出口*。
  - 遞迴會因為呼叫的對象不同，而有兩種模式：
    - 直接遞迴（Direct Recursion）：指遞迴數函數中，允許直接呼叫該函數本身。
    - 間接遞迴（Indirect Recursion）：指遞迴函數中，呼叫其他遞回函數，再從其他遞回函數呼叫原來的遞回函數。
  - 範例：[階乘](./lib/recursion/Factorial.cs)、[費式級數（Fibonacci Polynomial）](./lib/recursion/Fibonacci.cs)。
- 動態規劃法（Dynamic Programming Algorithm, DPA）：類似分治法，用來研究多階段決策過程的優化過程與求得一個問題的最佳解，但與分治法不同的是，動態規劃法可以讓每一個子問題的答案被儲存，以供下次求解時直接取用，減少再次計算所發費之時間。
- [疊代法（Iterative method）](./lib/iterative/Iterative.cs)：指無法用公式一次求解，需反覆運算，例如用迴圈去循環重複程式碼的某些部份來得到答案。
- 貪心法（Greed Method）：方法是從一個起點開始，在每一個解決問題的步驟，都採取對當前狀態最有利或最優化的選擇，逐步逼近給定的目標，當達到某一步無法再前進時，演算法停止。貪心法容易過早做決定，只能滿足某些約束條件的可行解的範圍，經常用在求圖形的最小生成樹（MST）、最短路徑與霍哈夫曼編碼等。
- 枚舉法：又稱窮舉法，根據問題要求，枚舉所有可能解答，或把問題分為不重複、不遺漏的有限種情況，一一枚舉並加以解決。
- 巴斯卡（Pascal）三角形演算法：計算出每一個三角形位置的數值，三角形上每一個數字會對應一個 `rCn`，r 代表 row，n 為 column，其中 r 與 n 都由數字 0 開始。
- 質數求解演算法：Eratosthenes 求質數方法。

## 演算法效能分析

是對程式的效能的評估，程式的執行時間稱為「時間複雜度」（Time Complexity），而程式佔用電腦記憶體的空間大小稱為「空間複雜度」（Space Complexity）。

### 空間複雜度

以概量來衡量所需的記憶體空間，通常可區分為「固定記憶體空間」（基本程式碼、常數、變數等）與「變動記憶體空間」（隨 runtime 而改變大小的使用空間，如參考型態變數），*若存粹從程式或演算法的效能角度來看，應該以執行時間為主要評估與分析的依據*。

### 時間複雜度

同樣以概量的觀念作為衡量標準，定義如下：

> **理想狀態下的計算機中，定義一個 `O(n)` 來表示程式執行所花費的時間，其中 `n` 表示資料輸入量，此種衡量標準稱為 Big-oh。**

分析演算法的時間複雜度必須考慮他的成長比率（Rate of Growth），而時間複雜度本身也是一種「漸進表示」（Asymptotic Notation）。

### Big-Oh

O(f(n)) 可視為某演算法在電腦中所需執行時間不會超過某一常數倍的 f(n)，也就是說當某個演算法的執行時間 T(n) 的時間複雜度為 O(f(n))。

意味存在兩個常數 c 與 n<sub>0</sub>，則若 n >= n<sub>0</sub>，則 T(n) <= cf(n)，f(n) 又稱之為執行時間的成長率。

- 常數 c：
  - 常數 c 代表一個正數，他是一個乘法因子，表示某個演算法執行時間部會超過某一常數倍數的 f(n)。
  - 當我們說 T(n) 是 O(f(n))，我們是說存在一個正數 c，使得當 n 足夠大時，T(n) 不會超過 cf(n)。
  - 常數 c 可以視為一個限制因子，它確保 T(n) 不會無限制地增長。
- n<sub>0</sub>（n-naught）：
  - n<sub>0</sub> 代表一個非負整數，通常是一個較小的數字。
  - 當 n >= n<sub>0</sub> 時，我們認為演算法的效能分析是有效的，也就是 T(n) 的時間複雜度為 O(f(n))。
  - n<sub>0</sub> 可視為一個起始點，表示從這個點開始，演算法的時間複雜度符合 O(f(n))。

#### 常見 Big-Oh

> 時間複雜度只是執行次數的概略量度層級，並非真實執行次數。

| Big-Oh | 特色與說明 |
| --- | --- |
| O(1) | 常數時間（constant time），執行時間是一個常數倍。 |
| O(n) | 線性時間（linear time），執行時間會隨資料及和大小而線性成長。 |
| O(log<sub>2</sub>n) | 次線性時間（sub-linear time），成長速度比線性時間慢，但比常數時間快。 |
| O(n<sup>2</sup>) | 平方時間（quadratic time），執行時間成二次方的成長。 |
| O(n<sup>3</sup>) | 立方時間（cubic time），執行時間成三次方的成長。 |
| O(2<sup>n</sup>) | 指數時間（exponential time），執行時間成二的 n 次方的成長。 |
| O(nlog<sub>2</sub>n) | 線性乘對數時間，介於線性及二次方成長的中間。 |

### Ω （omega）

同樣是時間複雜度的漸近表示法，如果 Big-oh 是執行時間量度的最壞情況，那麼 Ω 就是最好的情況。

對 f(n) = Ω(g(n)) （big-omega of g(n)），意思是存在常數 c 和 n<sub>0</sub>，對所有 n 而言，n >= n<sub>0</sub> 時，f(n) >= cg(n) 均成立。例如 f(n) = 5n + 6，存在 c = 5、n<sub>0</sub> = 1，對所有 n >= 1 時，5n + 6 >= 5n，因此 f(n) = Ω(n) 而言，n 就是成長的最大函數。

### θ （theta）

比 Big-oh 與 Ω 更精確的漸近表示法。

f(n) = θ(g(n)) （big-theta of g(n)），意思是存在常數 c<sub>1</sub>、c<sub>2</sub>、n<sub>0</sub>，對所有的 n >= n<sub>0</sub> 時，c<sub>1</sub>g(n) <= f(n) <= c<sub>2</sub>g(n) 均成立。換句話說，當 f(n) = θ(g(n)) 時，就表示 g(n) 可代表 f(n) 的上限與下限。
