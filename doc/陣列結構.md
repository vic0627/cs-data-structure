# 陣列結構

@todo 轉置矩陣 範例

「線性串列」（Linear List）是 n 個元素的有限序列（n >= 0），將元素排成一列，除了第一個與最後一個元素，每個元素都匯錢後相鄰。

## 線性串列簡介

定義：

- 有序串列可以是空集合，或者可以寫成：a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>..., a<sub>n-1</sub>, a<sub>n</sub>。
- 存在唯一的第一個元素 a<sub>1</sub>，與唯一的最後一個元素 a<sub>n</sub>。
- 除了 a<sub>1</sub>，每個元素都有唯一的先行者（precessor），例如 a<sub>i</sub> 的先行者是 a<sub>i-1</sub>。
- 除了 a<sub>n</sub>，每個元素都有唯一的後續者（successor），例如 a<sub>i</sub> 的後續者是 a<sub>i+1</sub>。

常見運算方式：

- 計算串列長度 n。
- 取出串列中第 i 項元素並加以修正。
- 插入一個新元素到第 i 項，並使原來的第 i 項（含）以後的元素後移一個項次。
- 刪除第 i 項的元素，並使原來的第 i 項（含）以後的元素前移一個項次。
- 由左至右或由右至左讀取串列中的元素。
- 在第 i 項存入新值，並取代舊值。
- 複製串列。
- 合併串列。

> i 值範圍：1 <= i <= n

### 儲存結構簡介

按照記憶體儲存的方式，可以分為以下兩種：

- 靜態資料結構（Static Data Structure）：或稱「密集串列」（Dense List），將有序串列的資料使用連續記憶體空間（Contiguous Allocation） 來儲存，在編譯時，就必須配置最大記憶體空間給相關變數，容易造成記憶體浪費，如陣列（Array）。
  - 優點：讀取與修改串列中任一元素的時間都固定。
  - 缺點：插入或刪除資料須移動大量資料。
- 動態資料結構（Dynamic Data Structure）：或稱「鏈結串列」（Linked List），將具有線性串列原理的資料，使用不連續的記憶體空間來儲存。
  - 優點：
    - 資料的插入或刪除很方便，不須移動大量資料。
    - 記憶體配置發生於 runtime，不須事先宣告。
  - 缺點：
    - 設計資料結構較麻煩。
    - 無法隨機讀取，必須透過循序方法找到目標資料。

## 認識陣列

「陣列」（Array）是一種緊密相鄰的可數記憶體，提供一個能夠直接存取單一資料內容的運作方式，在程式語言中通常會包含以下幾種屬性：

- 起始位址：表示陣列名稱（或陣列的第一個元素）所在記憶體中的起始位址。
- 維度（dimension）：代表此陣列維幾維陣列。
- 索引上下限：記憶體所儲存的上標與下標。
- 陣列元素個數：索引上下限的差 + 1。
- 陣列型態：決定陣列元素在記憶體所佔有的大小。

多維陣列也必須在一維的實體記憶體中表示，因為記憶體位置都是依線性順序遞增。

### 一維陣列

C# 中，一維陣列的宣告語法：

```cs
資料型別 [] 陣列名稱 = new 資料型別[元素個數];
```

- 資料型別：表示該陣列存放的資料型態，可以是 Primitive Data Type 或 Structured Data Type。
- 陣列名稱：命名規則與變數相同。
- 元素個數：表示陣列可存放的資料筆數，為一個正整數常數。

範例：[利用一維陣列尋找與儲存範圍 1 到 MAX 內的所有質數](../lib/array/Prime.cs)

### 二維陣列

C# 中，二維陣列的宣告語法：

```cs
資料型別 [,] 陣列名稱 = new 資料型別[第一維長度, 第二維長度];
```

例如宣告一個 2 列 3 行的陣列：

```cs
int [,] a = new int[2,3]
```

一維陣列的延伸，例如一個含有 m * n 個元素的二維陣列 A(1:m, 2:n)，m 為列數、n 為行數，A[4][4] 陣列在直觀平面上排列方式如下：

<table>
  <tbody>
    <tr>
      <td>A[0][0]</td>
      <td>A[0][1]</td>
      <td>A[0][2]</td>
      <td>A[0][3]</td>
    </tr>
    <tr>
      <td>A[1][0]</td>
      <td>A[1][1]</td>
      <td>A[1][2]</td>
      <td>A[1][3]</td>
    </tr>
    <tr>
      <td>A[2][0]</td>
      <td>A[2][1]</td>
      <td>A[2][2]</td>
      <td>A[2][3]</td>
    </tr>
    <tr>
      <td>A[3][0]</td>
      <td>A[3][1]</td>
      <td>A[3][2]</td>
      <td>A[3][3]</td>
    </tr>
  </tbody>
</table>

然而，電腦的記憶體中是無法以矩陣方式儲存，必須以線性方式，將其視為一維陣列的延伸來處理，通常依不同程式語言，可分為以下兩種儲存方式：

- 以列為主（Row-major）：存放順序為 a<sub>11</sub>, a<sub>12</sub>, ..., a<sub>1n</sub>, a<sub>21</sub>, a<sub>22</sub>, ..., a<sub>mn</sub>，陣列元素 a<sub>ij</sub> 與記憶體位置有下列關係：

  **Loc(a<sub>ij</sub>) = α + n * (i - 1) * d + (j - 1) * d**

- 以行為主（Column-major）：存放順序為 a<sub>11</sub>, a<sub>21</sub>, ..., a<sub>m1</sub>, a<sub>12</sub>, a<sub>22</sub>, ..., a<sub>mn</sub>，陣列元素 a<sub>ij</sub> 與記憶體位置有下列關係：

  **Loc(a<sub>ij</sub>) = α + (i - 1) * d + m * (j - 1) * d**

> 以上皆假設 α 維陣列 A 在記憶體中起始位址，d 為單位空間。

範例：[利用二維陣列來儲存產生的亂數。](../lib/array/TwoDim.cs)

### 三維陣列

C# 中，三維陣列的宣告語法：

```cs
資料型別 [,,] 陣列名稱 = new 資料型別[第一維長度, 第二維長度, 第三維長度];
```

表示法語二維陣列相同，皆可視為一維陣列的延伸。

若三維陣列式以線性的方式來處理，依樣可分為「以列為主」和「以行為主」。

- 以列為主（Row-major）：將陣列 A 視為 u<sub>1</sub> 個 u<sub>2</sub> * u<sub>3</sub> 的二維陣列，再將每個陣列視為有 u<sub>2</sub> 個一維陣列，每個一維陣列可包含 u<sub>3</sub> 的元素。
  
  **Loc(A(i, j, k)) = α + (i - 1)u<sub>2</sub>u<sub>3</sub>d + (j - 1)u<sub>3</sub>d + (k - 1)d**

- 以行為主（Column-major）：將陣列 A 視為 u<sub>3</sub> 個 u<sub>2</sub> * u<sub>1</sub> 的二維陣列，再將每個陣列視為有 u<sub>2</sub> 個一維陣列，每個一維陣列可包含 u<sub>1</sub> 的元素。
 
  **Loc(A(i, j, k)) = α + (k - 1)u<sub>2</sub>u<sub>1</sub>d + (j - 1)u<sub>1</sub>d + (i - 1)d**

> 以上皆假設 α 為起始位址，d 為單位空間。

範例：[利用三層巢狀迴圈找出 2 x 3 x 3 陣列中所储存的數值中的最小值。](../lib/array/ThreeDim.cs)

### n 維陣列

三維以上的陣列歸納為 n 維陣列。

- 以列為主（Row-major）：

  **Loc(A(i<sub>1</sub>, i<sub>2</sub>, i<sub>3</sub>..., i<sub>n</sub>)) = α + (i<sub>1</sub> - 1)u<sub>2</sub>u<sub>3</sub>...u<sub>n</sub>d + (i<sub>2</sub> - 1)u<sub>3</sub>u<sub>4</sub>...u<sub>n</sub>d + ... + (i<sub>n - 1</sub> - 1)u<sub>n</sub>d + (i<sub>n</sub> - 1)d**

- 以行為主（Column-major）：

  **Loc(A(i<sub>1</sub>, i<sub>2</sub>, i<sub>3</sub>..., i<sub>n</sub>)) = α + (i<sub>n</sub> - 1)u<sub>n - 1</sub>u<sub>n - 2</sub>...u<sub>1</sub>d + (i<sub>n - 1</sub> - 1)u<sub>n - 2</sub>u<sub>n - 3</sub>...u<sub>1</sub>d + ... + (i<sub>2</sub> - 1)u<sub>1</sub>d + (i<sub>1</sub> - 1)d**

## 矩陣與深度學習

從數學角度來看，對於 m x n 矩陣（Matrix）的形式，可以描述一個電腦中 A(m, n) 二維陣列。

```text
    ┌ a11 a12 a13 ┐
A = | a21 a22 a23 |
    └ a31 a32 a33 ┘
```

矩陣是高等代數中的常見工具，也常見於統計分析等應用數學學科中，許多矩陣的運算與應用，都可以用電腦中的二維陣列解決。

深度學習（Deep Learning, DL）是目前最熱門的話題，不但是人工智慧（AI）的一個分支，也可以看成是具有層次性的機器學習法（Machine Learning, ML），在深度學習中，線性代數是一個強大的數學工具，常需要使用大量矩陣運算來提高計算效率。

### 矩陣相加

矩陣相加較為簡單，前提是相加的兩矩陣列數與行數必須相等，相加後的列數與行數亦同，例如 A<sub>m * n</sub> + B<sub>m * n</sub> = C<sub>m * n</sub>。

```text
┌ 1  3  5  ┐   ┌ 9  8  7 ┐   ┌ 10 11 12 ┐
| 7  9  11 | + | 6  5  4 | = | 13 14 15 |
└ 13 15 17 ┘   └ 3  2  1 ┘   └ 16 17 18 ┘
```

### 矩陣相乘

兩矩陣相乘有條件限制，假設 A 為 m * n 之矩陣，B 為 n * p 的矩陣，而 A * B 的結果為 m * p 的矩陣 C。

```text
┌ a11 ... a1n ┐   ┌ b11 ... b1p ┐   ┌ c11 ... c1p ┐
| .   .   .   | x | .   .   .   | = | .   .   .   |
└ am1 ... amn ┘   └ bn1 ... bnp ┘   └ cm1 ... cmp ┘
```

而：

**c<sub>11</sub> = a<sub>11</sub> * b<sub>11</sub> + a<sub>12</sub> * b<sub>21</sub> + ... + a<sub>1n</sub> * b<sub>n1</sub>**
<br/>
.
<br/>
.
<br/>
**c<sub>1p</sub> = a<sub>11</sub> * b<sub>1p</sub> + a<sub>12</sub> * b<sub>2p</sub> + ... + a<sub>1n</sub> * b<sub>np</sub>**
<br/>
.
<br/>
.
<br/>
**c<sub>mp</sub> = a<sub>m1</sub> * b<sub>1p</sub> + a<sub>m2</sub> * b<sub>2p</sub> + ... + a<sub>mn</sub> * b<sub>np</sub>**

### 轉置矩陣

「轉置矩陣」（A<sup>t</sup>）就是把原矩陣的行座標元素與列座標矩陣相互調換。

假設 A<sup>t</sup> 為 A 的轉置矩陣：

```text
    ┌ 1  3  5  ┐
A = | 7  9  11 |
    └ 13 15 17 ┘
```

則有 A<sup>t</sup>[j, i] = A[i, j]：

```text
     ┌ 1  7  13 ┐
At = | 3  9  15 |
     └ 5  11 17 ┘
```
