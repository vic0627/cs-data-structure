# 陣列結構

「線性串列」（Linear List）是 n 個元素的有限序列（n >= 0），將元素排成一列，除了第一個與最後一個元素，每個元素都匯錢後相鄰。

-   [陣列結構](#陣列結構)
    -   [線性串列簡介](#線性串列簡介)
        -   [儲存結構簡介](#儲存結構簡介)
    -   [認識陣列](#認識陣列)
        -   [一維陣列](#一維陣列)
        -   [二維陣列](#二維陣列)
        -   [三維陣列](#三維陣列)
        -   [n 維陣列](#n-維陣列)
    -   [矩陣與深度學習](#矩陣與深度學習)
        -   [矩陣相加](#矩陣相加)
        -   [矩陣相乘](#矩陣相乘)
        -   [轉置矩陣](#轉置矩陣)
        -   [稀疏矩陣](#稀疏矩陣)
        -   [上三角形矩陣](#上三角形矩陣)
        -   [下三角形矩陣](#下三角形矩陣)
        -   [帶狀矩陣](#帶狀矩陣)
    -   [陣列與多項式](#陣列與多項式)

## 線性串列簡介

定義：

-   有序串列可以是空集合，或者可以寫成：a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>..., a<sub>n-1</sub>, a<sub>n</sub>。
-   存在唯一的第一個元素 a<sub>1</sub>，與唯一的最後一個元素 a<sub>n</sub>。
-   除了 a<sub>1</sub>，每個元素都有唯一的先行者（precessor），例如 a<sub>i</sub> 的先行者是 a<sub>i-1</sub>。
-   除了 a<sub>n</sub>，每個元素都有唯一的後續者（successor），例如 a<sub>i</sub> 的後續者是 a<sub>i+1</sub>。

常見運算方式：

-   計算串列長度 n。
-   取出串列中第 i 項元素並加以修正。
-   插入一個新元素到第 i 項，並使原來的第 i 項（含）以後的元素後移一個項次。
-   刪除第 i 項的元素，並使原來的第 i 項（含）以後的元素前移一個項次。
-   由左至右或由右至左讀取串列中的元素。
-   在第 i 項存入新值，並取代舊值。
-   複製串列。
-   合併串列。

> i 值範圍：1 <= i <= n

### 儲存結構簡介

按照記憶體儲存的方式，可以分為以下兩種：

-   靜態資料結構（Static Data Structure）：或稱「密集串列」（Dense List），將有序串列的資料使用連續記憶體空間（Contiguous Allocation） 來儲存，在編譯時，就必須配置最大記憶體空間給相關變數，容易造成記憶體浪費，如陣列（Array）。
    -   優點：讀取與修改串列中任一元素的時間都固定。
    -   缺點：插入或刪除資料須移動大量資料。
-   動態資料結構（Dynamic Data Structure）：或稱「鏈結串列」（Linked List），將具有線性串列原理的資料，使用不連續的記憶體空間來儲存。
    -   優點：
        -   資料的插入或刪除很方便，不須移動大量資料。
        -   記憶體配置發生於 runtime，不須事先宣告。
    -   缺點：
        -   設計資料結構較麻煩。
        -   無法隨機讀取，必須透過循序方法找到目標資料。

## 認識陣列

「陣列」（Array）是一種緊密相鄰的可數記憶體，提供一個能夠直接存取單一資料內容的運作方式，在程式語言中通常會包含以下幾種屬性：

-   起始位址：表示陣列名稱（或陣列的第一個元素）所在記憶體中的起始位址。
-   維度（dimension）：代表此陣列維幾維陣列。
-   索引上下限：記憶體所儲存的上標與下標。
-   陣列元素個數：索引上下限的差 + 1。
-   陣列型態：決定陣列元素在記憶體所佔有的大小。

多維陣列也必須在一維的實體記憶體中表示，因為記憶體位置都是依線性順序遞增。

### 一維陣列

C# 中，一維陣列的宣告語法：

```cs
資料型別 [] 陣列名稱 = new 資料型別[元素個數];
```

-   資料型別：表示該陣列存放的資料型態，可以是 Primitive Data Type 或 Structured Data Type。
-   陣列名稱：命名規則與變數相同。
-   元素個數：表示陣列可存放的資料筆數，為一個正整數常數。

範例：[利用一維陣列尋找與儲存範圍 1 到 MAX 內的所有質數](../lib/array/Prime.cs)

### 二維陣列

C# 中，二維陣列的宣告語法：

```cs
資料型別 [,] 陣列名稱 = new 資料型別[第一維長度, 第二維長度];
```

例如宣告一個 2 列 3 行的陣列：

```cs
int [,] a = new int[2,3]
```

一維陣列的延伸，例如一個含有 m \* n 個元素的二維陣列 A(1:m, 1:n)，m 為列數、n 為行數，A[4][4] 陣列在直觀平面上排列方式如下：

<table>
  <tbody>
    <tr>
      <td>A[0][0]</td>
      <td>A[0][1]</td>
      <td>A[0][2]</td>
      <td>A[0][3]</td>
    </tr>
    <tr>
      <td>A[1][0]</td>
      <td>A[1][1]</td>
      <td>A[1][2]</td>
      <td>A[1][3]</td>
    </tr>
    <tr>
      <td>A[2][0]</td>
      <td>A[2][1]</td>
      <td>A[2][2]</td>
      <td>A[2][3]</td>
    </tr>
    <tr>
      <td>A[3][0]</td>
      <td>A[3][1]</td>
      <td>A[3][2]</td>
      <td>A[3][3]</td>
    </tr>
  </tbody>
</table>

然而，電腦的記憶體中是無法以矩陣方式儲存，必須以線性方式，將其視為一維陣列的延伸來處理，通常依不同程式語言，可分為以下兩種儲存方式：

-   以列為主（Row-major）：存放順序為 a<sub>11</sub>, a<sub>12</sub>, ..., a<sub>1n</sub>, a<sub>21</sub>, a<sub>22</sub>, ..., a<sub>mn</sub>，陣列元素 a<sub>ij</sub> 與記憶體位置有下列關係：

    **Loc(a<sub>ij</sub>) = α + n \* (i - 1) \* d + (j - 1) \* d**

-   以行為主（Column-major）：存放順序為 a<sub>11</sub>, a<sub>21</sub>, ..., a<sub>m1</sub>, a<sub>12</sub>, a<sub>22</sub>, ..., a<sub>mn</sub>，陣列元素 a<sub>ij</sub> 與記憶體位置有下列關係：

    **Loc(a<sub>ij</sub>) = α + (i - 1) \* d + m \* (j - 1) \* d**

> 以上皆假設 α 為陣列 A 在記憶體中起始位址，d 為單位空間。

範例：[利用二維陣列來儲存產生的亂數。](../lib/array/TwoDim.cs)

### 三維陣列

C# 中，三維陣列的宣告語法：

```cs
資料型別 [,,] 陣列名稱 = new 資料型別[第一維長度, 第二維長度, 第三維長度];
```

表示法語二維陣列相同，皆可視為一維陣列的延伸。

若三維陣列式以線性的方式來處理，依樣可分為「以列為主」和「以行為主」。

-   以列為主（Row-major）：將陣列 A 視為 u<sub>1</sub> 個 u<sub>2</sub> \* u<sub>3</sub> 的二維陣列，再將每個陣列視為有 u<sub>2</sub> 個一維陣列，每個一維陣列可包含 u<sub>3</sub> 的元素。

    **Loc(A(i, j, k)) = α + (i - 1)u<sub>2</sub>u<sub>3</sub>d + (j - 1)u<sub>3</sub>d + (k - 1)d**

-   以行為主（Column-major）：將陣列 A 視為 u<sub>3</sub> 個 u<sub>2</sub> \* u<sub>1</sub> 的二維陣列，再將每個陣列視為有 u<sub>2</sub> 個一維陣列，每個一維陣列可包含 u<sub>1</sub> 的元素。

    **Loc(A(i, j, k)) = α + (k - 1)u<sub>2</sub>u<sub>1</sub>d + (j - 1)u<sub>1</sub>d + (i - 1)d**

> 以上皆假設 α 為起始位址，d 為單位空間。

範例：[利用三層巢狀迴圈找出 2 x 3 x 3 陣列中所储存的數值中的最小值。](../lib/array/ThreeDim.cs)

### n 維陣列

三維以上的陣列歸納為 n 維陣列。

-   以列為主（Row-major）：

    **Loc(A(i<sub>1</sub>, i<sub>2</sub>, i<sub>3</sub>..., i<sub>n</sub>)) = α + (i<sub>1</sub> - 1)u<sub>2</sub>u<sub>3</sub>...u<sub>n</sub>d + (i<sub>2</sub> - 1)u<sub>3</sub>u<sub>4</sub>...u<sub>n</sub>d + ... + (i<sub>n - 1</sub> - 1)u<sub>n</sub>d + (i<sub>n</sub> - 1)d**

-   以行為主（Column-major）：

    **Loc(A(i<sub>1</sub>, i<sub>2</sub>, i<sub>3</sub>..., i<sub>n</sub>)) = α + (i<sub>n</sub> - 1)u<sub>n - 1</sub>u<sub>n - 2</sub>...u<sub>1</sub>d + (i<sub>n - 1</sub> - 1)u<sub>n - 2</sub>u<sub>n - 3</sub>...u<sub>1</sub>d + ... + (i<sub>2</sub> - 1)u<sub>1</sub>d + (i<sub>1</sub> - 1)d**

## 矩陣與深度學習

從數學角度來看，對於 m x n 矩陣（Matrix）的形式，可以描述一個電腦中 A(m, n) 二維陣列。

```text
    ┌ a11 a12 a13 ┐
A = | a21 a22 a23 |
    └ a31 a32 a33 ┘
```

矩陣是高等代數中的常見工具，也常見於統計分析等應用數學學科中，許多矩陣的運算與應用，都可以用電腦中的二維陣列解決。

深度學習（Deep Learning, DL）是目前最熱門的話題，不但是人工智慧（AI）的一個分支，也可以看成是具有層次性的機器學習法（Machine Learning, ML），在深度學習中，線性代數是一個強大的數學工具，常需要使用大量矩陣運算來提高計算效率。

### 矩陣相加

矩陣相加較為簡單，前提是相加的兩矩陣列數與行數必須相等，相加後的列數與行數亦同，例如 A<sub>m _ n</sub> + B<sub>m _ n</sub> = C<sub>m \* n</sub>。

```text
┌ 1  3  5  ┐   ┌ 9  8  7 ┐   ┌ 10 11 12 ┐
| 7  9  11 | + | 6  5  4 | = | 13 14 15 |
└ 13 15 17 ┘   └ 3  2  1 ┘   └ 16 17 18 ┘
```

### 矩陣相乘

兩矩陣相乘有條件限制，假設 A 為 m \* n 之矩陣，B 為 n \* p 的矩陣，而 A \* B 的結果為 m \* p 的矩陣 C。

```text
┌ a11 ... a1n ┐   ┌ b11 ... b1p ┐   ┌ c11 ... c1p ┐
| .   .   .   | x | .   .   .   | = | .   .   .   |
└ am1 ... amn ┘   └ bn1 ... bnp ┘   └ cm1 ... cmp ┘
```

而：

**c<sub>11</sub> = a<sub>11</sub> \* b<sub>11</sub> + a<sub>12</sub> \* b<sub>21</sub> + ... + a<sub>1n</sub> \* b<sub>n1</sub>**
<br/>
.
<br/>
.
<br/>
**c<sub>1p</sub> = a<sub>11</sub> \* b<sub>1p</sub> + a<sub>12</sub> \* b<sub>2p</sub> + ... + a<sub>1n</sub> \* b<sub>np</sub>**
<br/>
.
<br/>
.
<br/>
**c<sub>mp</sub> = a<sub>m1</sub> \* b<sub>1p</sub> + a<sub>m2</sub> \* b<sub>2p</sub> + ... + a<sub>mn</sub> \* b<sub>np</sub>**

### 轉置矩陣

「轉置矩陣」（A<sup>t</sup>）就是把原矩陣的行座標元素與列座標矩陣相互調換。

假設 A<sup>t</sup> 為 A 的轉置矩陣：

```text
    ┌ 1  3  5  ┐
A = | 7  9  11 |
    └ 13 15 17 ┘
```

則有 A<sup>t</sup>[j, i] = A[i, j]：

```text
     ┌ 1  7  13 ┐
At = | 3  9  15 |
     └ 5  11 17 ┘
```

### 稀疏矩陣

「稀疏矩陣」（Sparse Matrix）對於 ADT 而言是一個很好的例子，如果一個矩陣中，大部分元素為零的話，就可稱其為稀疏矩陣。

```text
┌ 0  0  0  12 0  -5  ┐
| 0  0  5  0  0  0   |
| 0  0  0  0  3  0   |
└ 45 0  0  0  -7 0   ┘
```

當矩陣很大時，例如 1000 \* 1000 的矩陣，且大部分的元素都是 0，以傳統的二維陣列方式存放，會十分浪費儲存空間，而改進方式可以利用「三項式」（3-tuple）的資料結構。

三項式，把每一個非零項目以 `(i, j, item-value)` 來表示，假設一個稀疏矩陣有 n 個非零項目，就可以利用一個 `A(0:n, 1:3)` 的二維陣列來表示，或稱「壓縮矩陣」。

以上面 4 \* 6 稀疏矩陣為例，可以如下表示：

<table>
  <tbody>
    <tr>
      <td>4</td>
      <td>6</td>
      <td>6</td>
    </tr>
    <tr>
      <td>1</td>
      <td>4</td>
      <td>12</td>
    </tr>
    <tr>
      <td>1</td>
      <td>6</td>
      <td>-5</td>
    </tr>
    <tr>
      <td>2</td>
      <td>3</td>
      <td>5</td>
    </tr>
    <tr>
      <td>3</td>
      <td>5</td>
      <td>3</td>
    </tr>
    <tr>
      <td>4</td>
      <td>1</td>
      <td>45</td>
    </tr>
    <tr>
      <td>4</td>
      <td>5</td>
      <td>-7</td>
    </tr>
  </tbody>
</table>

-   `A(0, 1)`：表示此矩陣的列數
-   `A(0, 2)`：表示此矩陣的行數
-   `A(0, 3)`：表示此矩陣非零項目的總數

### 上三角形矩陣

「上三角形矩陣」（Upper Triangular Matrix）是一種對角線以下的元素皆為 0 的 n \* n 矩陣。
又可分為「右上三角形矩陣」（Right Upper Triangular Matrix）與「左上三角形矩陣」（Left Upper Triangular Matrix）。

-   **右上三角形矩陣**

    有一 n \* n 的矩陣 A，設 i > j 時 A(i, j) = 0：

    ```txt
        ┌ a11  a12  a13 ... a1n ┐
        |      a22  a23       . |
    A = |            ..       . |
        |             .   an-1n |
        └                   ann ┘
    ```

    1. A(i, j)
        - if (i > 1) A(i, j) = 0
        - if (i <= j) A(i, j) = a<sub>ij</sub>
    2. 共有 1 + 2 + ... + n = n \* (n + 1) / 2 個非零項目

    此二維矩陣的非零項目可依序對應成一維矩陣，即須一個一維陣列 B(1:n \* (n + 1) / 2) 來儲存。

    -   以列為主

        ```txt
        [B(1), B(2), B(3), ..., B(n), B(n+1), ..., B(k), ..., B(n * (n + 1) / 2)]
        [a11, a12, a13, ..., a1n, a22, ..., aij, ..., ann]
        ```

        k 會等於第一列到第 i - 1 列所有元素個數，減去第一列到第 i - 1 列中所有值為零的元素個數，再加上 a<sub>ij</sub> 所在的行數 j：

        ```txt
        k = n * (i - 1) - i * (i - 1) / 2 + j
        ```

    -   以行為主

        ```txt
        [B(1), B(2), ..., B(k), ..., B(n * (n + 1) / 2)]
        [a11, a12, a22, a23, a33, ..., aij, ..., ann]
        ```

        k 會等於第一行到第 j -1 的所有非零元素個數，加上 a<sub>ij</sub> 所在的列數 i：

        ```txt
        k = j * (i - 1) / 2 + i
        ```

-   **左上三角形矩陣**

    有一 n \* n 的矩陣 A，假設 i > n - j + 1 時，A(i,j) = 0：

    ```txt
        ┌ a11  a12  a13 ... ... a1n ┐
        | a21  a22  a23 ... a2n-1   |
    A = | a31  a32  ... a3n-2       |
        | ...                       |
        └ an1                       ┘
    ```

    -   以列為主

        ```txt
        [B(1), B(2), B(3), ..., B(n), B(n+1), ..., B(k), ..., B(n * (n + 1) / 2)]
        [a11, a12, a13, ..., a1n, a21, ..., aij, ..., an1]
        ```

        k 會等於第一列到第 i - 1 列所有元素個數，減去第一列到第 i - 2 列中所有值為零的元素個數，再加上 a<sub>ij</sub> 行數 j：

        ```txt
        k = n * (i - 1) - (i - 2) * ((i - 2) + 1) / 2 + j
          = n * (i - 1) - (i - 2) * (i - 1) / 2 + j
        ```

    -   以行為主

        ```txt
        [B(1), B(2), B(3), ..., B(n), B(n+1), ..., B(k), ..., B(n * (n + 1) / 2)]
        [a11, a21, a31, ..., an1, a12, ..., aij, ..., a1n]
        ```

        k 等於第一行到第 j - 1 行所有元素個數，減去第一行到第 j - 2 行中所有值為零的元素，再加上 a<sub>ij</sub> 所在列數 i：

        ```txt
        k = n * (j - 1) - (i - 2) * (i - 1) / 2 + i
        ```

### 下三角形矩陣

與上三角形矩陣相反，對角線以上元素皆為零的 n \* n 矩陣。
可分為「左下三角形矩陣」（Left Lower Triangular Matrix）與「右下三角形矩陣」（Rigth Lower Triangular Matrix）

-   **左下三角形矩陣**

    有一 n \* n 的矩陣 A，假設 i < j，那麼 A(i,j) = 0：

    ```txt
        ┌ a11                       ┐
        | a21  a22                  |
    A = | a31  a32  a33             |
        | ...  ...  ... ... ...     |
        └ an1  an2              ann ┘
    ```

    1. A(i,j)
        - if (i < j) A(i,j) = 0
        - if (i >= j) A(i,j) = a<sub>ij</sub>
    2. 共有 n \* (n + 1) / 2 個非零項目

    -   以列為主

        ```txt
        [B(1), B(2), ..., B(k), ..., B(n * (n + 1) / 2)]
        [a11, a21, a22, a31, a32, ..., aij, ..., ann]
        ```

        k 會等於第一列到第 i - 1 列所有非零元素個數，加上 a<sub>ij</sub> 所在行數 j：

        ```txt
        k = i (i - 1) / 2 + j
        ```

    -   以行為主

        ```txt
        [B(1), B(2), B(3), ..., B(n), ..., B(k), ..., B(n * (n + 1) / 2)]
        [a11, a21, a31, ..., an1, ..., aij, ..., ann]
        ```

        k 會等於第一行到第 j - 1 行所有非零元素個數，減去第一行到第 j - 1 行所有值為零的元素個數，再加上 a<sub>ij</sub> 所在列數 i：

        ```txt
        k = n * (j - 1) + i - (j - 1) * (1 + (j - 1)) / 2
          = n * (j - 1) + i - j * (j - 1) / 2
        ```

-   **右下三角形矩陣**

    有一 n \* n 的矩陣 A，假設 i < n - j + 1，則 A(i,j) = 0：

    ```txt
        ┌ 0   0   0   ... ... a1n ┐
        | 0             a2n-1 a2n |
    A = | .       ...   a3n-1 a3n |
        | .   ...             ... |
        └ an1 ... ... ... ... ann ┘
    ```

    1. A(i,j)
        - if (i < n - j + 1) A(i,j) = 0
        - if (i >= n - j + 1) A(i,j) = a<sub>ij</sub>
    2. 共有 n \* (n + 1) / 2 個非零元素

    -   已列為主

        ```txt
        [B(1), B(2), ..., B(k), ..., B(n * (n + 1) / 2)]
        [a1n, a2n-1, a2n, a3n-2, ..., aij, ..., ann]
        ```

        k 會等於第一列到第 i - 1 列所有非零元素個數，加上 a<sub>ij</sub> 所在行數 j，再減去該行所有值為零的個數：

        ```txt
        k = (i - 1) / 2 * (1 + (i - 1)) + j - (n - i)
          = ((i * (i - 1)) + 2 * i) / 2 + j - n
          = i * (i + 1) / 2 + j - n
        ```

    -   以行為主

        ```txt
        [B(1), B(2), ..., B(k), ..., B(n * (n + 1) / 2)]
        [an1, an-12, an2, an-23,  ..., aij, ..., ann]
        ```

        k 會等於第一行到第 j - 1 行所有非零元素個數，加上 a<sub>ij</sub> 所在的 i 列，再減去該列中所有值為零的元素個數：

        ```txt
        k = ((j - 1) * (1 + (j - 1))) / 2 + i - (n - j)
          = j * (j + 1) / 2 + i - n
        ```

### 帶狀矩陣

「帶狀矩陣」（Band Matrix）在應用上較為特殊且稀少，定義是在上三角形矩陣中，右上方的元素皆為零，而在下三角形矩陣中，左下方的元素也都是零。

```txt
┌ a11 a21 0   0   0   ┐
| a12 a22 a32 0   0   |
| 0   a23 a33 a43 0   |
| 0   0   a34 a44 a54 |
└ 0   0   0   a45 a55 ┘
```

-   if (|i - j| > 1) a<sub>ij</sub> = 0

同為稀疏矩陣，在儲存上也只將非零元素存在一維陣列中，對應關係同樣可分為以行為主與以列為主兩種。

## 陣列與多項式

> [!NOTE]
> 多項式是數學中重要的表現方式，可以將多項式以陣列（Array）或鏈結串列（Linked List）來儲存，而此章將先以陣列結構表示。

假如有一多項式 P(x) = a<sub>n</sub>x<sup>n</sup> + a<sub>n-1</sub>x<sup>n-1</sup> + ... + a<sub>1</sub>x + a<sub>0</sub>，則稱 P(x) 為一 n 次多項式，若使用陣列結構儲存，有底下兩種模式：

1. **使用一個 n + 2 長度的一維陣列存放**，陣列首位儲存最大指數 n，其他位置依照指數 n 遞減。P = (n, a<sub>n</sub>, a<sub>n-1</sub>, ..., a<sub>1</sub>, a<sub>0</sub>) 存在 A(1:n+2)，例如 P(x) = 2x<sup>5</sup> + 3x<sup>4</sup> + 5x<sup>2</sup> + 4x + 1 以陣列表示時：

    ```txt
    A = { 5, 2, 3, 0, 5, 4, 1 }
    ```

    - 優點：對於多項式各種運算（如加法與乘法）較為方便設計。
    - 缺點：若多項式的係數多半為零，如 x<sup>100</sup>+1，會很浪費空間。

2. **只儲存多項式中非零項目**，若有 m 個非零項目，就以 2m + 1 長度陣列儲存每一個非零項目的指數與係數，陣列首位為此多項式非零項目的個數。例如 P(x) = 2x<sup>5</sup> + 3x<sup>4</sup> + 5x<sup>2</sup> + 4x + 1，表示為 A(1:2m+1) 陣列：

    ```txt
    A = { 5, 2, 5, 3, 4, 5, 2, 4, 1, 1, 0 }
    ```

    - 優點：避免浪費不必要的記憶體空間。
    - 缺點：在多項式的演算法設計時，會複雜許多。
